%
%    Another C++ cheat sheet but written in LaTeX to be printed out on A3 paper
%    Copyright (C) 2021 Michele Iarossi - michele@mathsophy.com
%
%    This program is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation version 3 of the License.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program.  If not, see <https://www.gnu.org/licenses/>.
%
%
% Example of document composed in LaTeX
%
%
% Source file ending with .tex
%

% Preamble starts here: includes further global commands and specifications
% In the following, the option 10pt is a global option passed to all
% the packages
\documentclass[10pt]{article}

% Using Courier font
\renewcommand{\ttdefault}{pcr}

% A4 paper size
\usepackage[a4paper]{geometry}

% Change the color of the text
\usepackage{xcolor}

% multiple columns in the toc
\usepackage{multicol}

% Add filling dots for sections in the toc
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

% C++ code listings embedded in the document
\usepackage{listings}
\lstset{
    language = [11]C++,
    basicstyle = \ttfamily,
    morekeywords = narrow\_cast,
    keywordstyle=\bfseries,
    escapeinside={(*<}{>*)},          % if you want to add LaTeX within your code
}

% This encoding corresponds to the encoding used by TexShop for saving this file
% The option utf8 is a local option, valid only for the package inputenc
\usepackage[utf8]{inputenc}

% Layout package shows the layout of the page
% You can issue the command \layout for printing the applied layout of the pages
\usepackage{layout}

% Some length parameters are rubber lengths: they stretch or reduce as needed
% 1ex means one time the height of the letter x
% Customize page layout for more space
\setlength{\parskip}{1ex plus0.5ex minus0.2ex}

% No header, only footer
\usepackage{fancyhdr}
\fancypagestyle{plain}{
    \fancyfoot[L]{\small www.mathsophy.com}
    \fancyfoot[C]{\small \thepage}
    \fancyfoot[R]{\small GNU GPL v3.0}}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\fancyhead{}
\fancyfoot[L]{\small www.mathsophy.com}
\fancyfoot[C]{\small \thepage}
\fancyfoot[R]{\small GNU GPL v3.0}

\setcounter{secnumdepth}{0} % sections are level 1

% This is the body: text mixed with commands

% Commands have the following general syntax:
% \name[optional]{mandatory}
\begin{document}

% Set title and author
\title{\emph{C++ basics}}
\author{Michele Iarossi\thanks{\texttt{michele@mathsophy.com}}}
\date{\small \today~-~Version 1.31~-~GNU GPL v3.0}

%\layout

\maketitle

\small

\begin{frame}{}
\setlength\columnsep{1cm}
\begin{multicols}{2}
\tableofcontents
\end{multicols}
\end{frame}

\noindent
In the following code snippets, the standard I/O library and namespace are always used:
\begin{lstlisting}
#include <iostream>
using namespace std;
\end{lstlisting}

\newpage
%
% Type safety
%
\section{Type safety}
\small
$\Rightarrow$ Universal and uniform initialisation prevents narrowing
conversions from happening:
\begin{lstlisting}
// safe conversions
double x {54.21};
int a {2342};

// unsafe conversions (compile error!)
int y {x};
char b {a};
\end{lstlisting}
%
% constexpr
%
\section{constexpr}
\small
There are two options:\\ \\
$\Rightarrow$ \textbf{constexpr} must be known at compile time:
\begin{lstlisting}
constexpr int max = 200;
constexpr int c = max + 2;
\end{lstlisting}
$\Rightarrow$ \textbf{const} variables don't change at runtime. They cannot be declared as
\textbf{constexpr} because their value is not known at compile time:
\begin{lstlisting}
// the value of (*<n>*) is not known at compile time
const int m = n + 1;
\end{lstlisting}
%
% Type casting
%
\section{Type casting}
\small
$\Rightarrow$ Use \textbf{static\_cast} for normal casting:
\begin{lstlisting}
// (*<int 15>*) to (*<double 15.0>*)
double num;
num = static_cast<double>(15);
\end{lstlisting}
%
% Functions
%
\section{Functions}
\small
$\Rightarrow$ With default trailing arguments only in the function declaration:
\begin{lstlisting}
// if (*<year>*) is omitted, then (*<year = 2000>*)
void set_birthday(int day, int month, int year=2000);
\end{lstlisting}
$\Rightarrow$ Omitting the name of an argument if not used anymore in the function definition:
\begin{lstlisting}
// argument (*<year>*) is not used anymore in the function definition
// (doesn't break legacy code!)
void set_birthday(int day, int month, int) { ...}
\end{lstlisting}
$\Rightarrow$ With read-only, read-write and copy-by-value parameters:
\begin{lstlisting}
// (*<day>*) input parameter passed by const reference (read-only)
// (*<month>*) output parameter to be changed by the function (read-write)
// (*<year>*) input parameter copied-by-value
void set_birthday(const int& day, int& month, int year);
\end{lstlisting}
$\Rightarrow$ Use a function for initialising an object with a complicated initialiser (we might not
know exactly when the object gets initialised):
\begin{lstlisting}
const Object& default_value()
{
  static const Object default(1,2,3);
  return default;
}
\end{lstlisting}

%
% Namespaces
%
\section{Namespaces}
\small
$\Rightarrow$ \textbf{using} declarations for avoiding fully qualified names:
\begin{lstlisting}
// use (*<string>*) instead of (*<std::string>*)
using std::string;

// use (*<cin>*), (*<cout>*) instead of (*<std::cin>*), (*<std::cout>*)
using std::cin;
using std::cout;
\end{lstlisting}
$\Rightarrow$ \textbf{using namespace} directives for including the whole namespace:
\begin{lstlisting}
using namespace std;
\end{lstlisting}
%
% Random numbers
%
\section{Random numbers}
\small
\begin{lstlisting}
#include <cstdlib>
#include <ctime>

// seed the generator
srand( time(0) );

// integer random number between 0 and RAND_MAX
int n = rand();
\end{lstlisting}
%\columnbreak
%
% Arrays
%
\section{Arrays}
\small
$\Rightarrow$ Range-based \textbf{for} statement:
\begin{lstlisting}
// changes the values and outputs 3579
int arr[] = {2, 4, 6, 8};

for (int& x : arr)
  x++;

for (auto x : arr)
  cout << x;
\end{lstlisting}
%
% Pointers
%
\section{Pointers}
\small
$\Rightarrow$ Simple object:
\begin{lstlisting}
// simple pointer to (*<double>*)
double *d = new double(5.123);

// delete the storage on the freestore
delete d;
\end{lstlisting}
$\Rightarrow$ Dynamic array:
\begin{lstlisting}
// dynamic array of (*<10 double>*)s
double *dd = new double[10];

// delete the storage on the freestore
delete [] dd;
\end{lstlisting}
$\Rightarrow$ Dynamic matrix:
\begin{lstlisting}
// dynamic matrix of (*<5 x 5 double>*)s memory allocation
double **m = new double*[5];
for (int i=0; i<5; i++)
    m[i] = new double[5];

// memory initialization    
for (int i=0; i<5; i++)
    for (int j=0; j<5; j++)
        m[i][j] = i*j;

// memory deallocation
for (int i=0; i<5; i++)
    delete[] m[i];
delete[] m;
\end{lstlisting}
%
% C-Strings
%
\section{C-Strings}
\small
$\Rightarrow$ Legacy strings from C:
\begin{lstlisting}
#include <cstring>
#include <cstdlib>

// (*<C-string>*) for max 10 characters
// long string + null char '\0'
const int SIZE = 10 + 1;
char msg[SIZE] = "Hello!";

// correct looping over (*<C-string>*)s
int i = 0;
while ( msg[i] != '\0' && i < SIZE)
{
   // process msg[i]
}

// safe string copy, at most 10 characters are copied
strncpy(msg, srcStr, 10);

// safe string compare, at most 10 characters are compared
strncmp(msg, srcStr, 10);

// safe string concatenation, at most 10 characters are concatenated
strncat(msg, srcStr, 10);

// from (*<C-string>*) to (*<int>*), (*<long>*), (*<float>*)
int    n = atoi("567");
long   n = atol("1234567");
double n = atof("12.345");
\end{lstlisting}
%
% Standard I/O
%
\section{Standard I/O}
\small
$\Rightarrow$ Format manipulators:
\begin{lstlisting}
#include <iomanip>

// set flag
cout.setf(ios::fixed);
// unset flag
cout.unsetf(ios::fixed);

// set (*<ios::fixed>*) or (*<ios::scientific>*) notation
cout.setf(ios::fixed);
cout << fixed;

// set precision
cout.precision(4);
cout << setprecision(4);

// set character text width
cout.width(10);
cout << setw(10);

// set (*<ios::left>*) or (*<ios::right>*) alignment
cout.setf(ios::left);
cout << left;

// always show decimal point and zeros
cout.setf(ios::showpoint);
cout << showpoint;

// always show plus sign
cout.setf(ios::showpos);
cout << showpos;
\end{lstlisting}
%
% Character I/O
%
\section{Character I/O}
\small
$\Rightarrow$ Single characters read and write:
\begin{lstlisting}
// read any character from (*<cin>*) (doesn't skip spaces, newlines, etc.)
char nextChar;
cin.get(nextChar);

// write a character to (*<cout>*)
cout.put(nextChar)

// read a whole line of 80 chars
char line[80+1];
cin.getline(line,81);

// put back (*<nextChar>*) to (*<cin>*), (*<nextChar>*) will be the next char read by (*<cin.get()>*)
cin.putback(nextChar);

// put back the last char got from (*<cin.get()>*) to (*<cin>*)
cin.unget();
\end{lstlisting}
%\columnbreak
%
% Files
%
\section{Files}
\small
$\Rightarrow$ Accessed by means of \textbf{ifstream} (input) or
\textbf{ofstream} (output) objects:
\begin{lstlisting}
#include <fstream>

// open input file 
ifstream in_stream {"infile.dat"};
// open output file
ofstream out_stream {"outfile.dat"};
\end{lstlisting}
$\Rightarrow$ Files can also be opened explicitely (not recommended):
\begin{lstlisting}
#include <fstream>

// input file 
ifstream in_stream;
// output file
ofstream out_stream;

// open files
in_stream.open("infile.dat");
out_stream.open("outfile.dat");
\end{lstlisting}
$\Rightarrow$ When checking for failure, the status flag needs to be cleared
in order to continue working with the file:
\begin{lstlisting}
// check for failure on input file
if ( !in_stream )
{
    if ( in_stream.bad() ) error("stream corrupted!");
    
    if ( in_stream.eof() )
    { 
        // no more data available
    }
    
    if ( in_stream.fail() )
    {
        // some format data error (recovery possible)
        // set back the state to good again
        in_stream.clear();
    }
}
\end{lstlisting}
$\Rightarrow$ Read and write:
\begin{lstlisting}
// read/write data
in_stream >> data1 >> data2;
out_stream << data1 << data2;
\end{lstlisting}
$\Rightarrow$ Read a line:
\begin{lstlisting}
string line;
getline(in_stream, line);
\end{lstlisting}
$\Rightarrow$ Ignore input (extract and discard):
\begin{lstlisting}
// ignore up to a newline or 9999 characters
in_stream.ignore(9999,'\n');
\end{lstlisting}
$\Rightarrow$ Move the file pointer:
\begin{lstlisting}
// skip 5 characters
in_stream.seekg(5);
\end{lstlisting}
$\Rightarrow$ Checking for end of file:
\begin{lstlisting}
// the failing read sets the EOF flag but avoids further processing
while ( in_stream >> next )
{
    // process next
}

// check the EOF flag
if ( in_stream.eof() )
    cout << "EOF reached!" << endl;
\end{lstlisting}
$\Rightarrow$ When a file object gets out of scope, the file is closed automatically, but explicit
close is also possible (not recommended):
\begin{lstlisting}
// explicitely close files
in_stream.close();
out_stream.close()
\end{lstlisting}
%
% Strings
%
\section{Strings}
\small
$\Rightarrow$ Strings as supported by the C++ standard library:
\begin{lstlisting}
#include <string>

// initialization
string s1 = "Hello";
string s2("World");

// concatenation
string s3 = s1 + ", " + s2;

// read a line
string line;
getline(cin,line);

// access to the ith character (no illegal index checking)
s1[i];

// access to the ith character (with illegal index checking)
s1.at(i);

// append
s1.append(s2);

// size and length
s1.size();
s1.length();

// substring from position 5 and length 4 characters
string substring;
substring = s4.substr(5,4);

// find (returns string::npos if not found)
size_t pos;
pos = s3.find("World");
if (pos == string::npos)
    cerr << "Error: String not found!\n";

// find starting from position 5
s3.find("l",5);

// C-string
s3.c_str();

// from (*<string>*) to (*<int>*), (*<long>*), (*<float>*)
int    n = stoi("456");
long   n = stol("1234567");
double n = stod("12.345");

// from numeric type to (*<string>*)
string s = to_string(123.456);
\end{lstlisting}
%
% Vectors
%
\section{Vectors}
\small
$\Rightarrow$ Sequence of elements accessed via an index:
\begin{lstlisting}
#include <vector>

// vector with base type (*<int>*)
vector<int> v = {2, 4, 6, 8};

// vector with 10 elements all initialised to 0
vector<int> v(10);

// access to the (*<i>*)th element
cout << v[i];

// add an element
v.push_back(10);

// range-for-loop
for (auto x : v)
  cout << v << endl;

// size
cout << v.size();

// capacity: number of elements currently allocated
cout << v.capacity();

// reserve more capacity e.g. at least 64 (*<int>*)s
v.reserve(64);
\end{lstlisting}
$\Rightarrow$ Throws an \textbf{out\_of\_range} exception if accessed out of bounds:
\begin{lstlisting}
// out of bounds access
vector<int> v = {2, 4, 6, 8};

try
{
    cout << v[7];
} catch (out_of_range)
{
    // access error!
}
\end{lstlisting}
%
% Enumerations
%
\section{Enumerations}
\small
$\Rightarrow$ \textbf{enum class} defines symbolic constants in the scope of the class:
\begin{lstlisting}
// enum definition
enum class Weekdays
{
    mon=1, tue, wed, thu, fri
};

// usage
Weekdays day = Weekdays::tue;
\end{lstlisting}
$\Rightarrow$ \textbf{int}s cannot be assigned to \textbf{enum class} and viceversa:
\begin{lstlisting}
// errors!
Weekdays day = 3;
int d = Weekdays::wed;
\end{lstlisting}
$\Rightarrow$ A conversion function should be written which uses unchecked conversions:
\begin{lstlisting}
// valid
Weekdays day = Weekdays(2);
int d = int(Weekdays::fri);
\end{lstlisting}
%
% Classes
%
\section{Classes}
\small
$\Rightarrow$ If you give no constructor, the compiler will generate a default constructor that does nothing.
If you give at least one constructor, then the C++ compiler will generate no other constructors.
\begin{lstlisting}
class Car
{
public:
    // constructor
    Car(double size);
    // mutators
    void set_engine_size(const double& size);
    // accessors
    double get_engine_size() const;
    // friend function
    friend bool equal(const Car& car1, const Car& car2);
private:	
    double engine_liter;
};

// constructor with member initialisation list
// the member variable is immediately initialised before the
// constructor body runs
Car::Car(double size) : engine_liter{size}
{
}

// parameter passed by reference for efficiency
void Car::set_engine_size(const double& size)
{
    engine_liter = size;
}

// constant member function doesn't change the object
double Car::get_engine_size() const
{
    return engine_liter;
}

// friend function with direct access to private members
bool equal(const Car &car1, const Car &car2)
{
    return car1.engine_liter == car2.engine_liter;
}
\end{lstlisting}
$\Rightarrow$ Constructor invocations:
\begin{lstlisting}
// all forms call the (*<Car(2000)>*) constructor
Car bmw {2000};
Car bmw = {2000};
Car bmw = Car{2000};
\end{lstlisting}
%
% Operator overloading
%
\section{Operator overloading}
\small
The behaviour is different if overloaded as class members or 
friend functions.
\\
\\
$\Rightarrow$ As class members:
\begin{lstlisting}
class Euro
{
    // constructor for  (*<euro>*)
    Euro(int euro);
    // constructor for  (*<euro>*) and (*<cents>*)
    Euro(int euro, int cents);
    // works for (*<Euro(5) + 2>*), equivalent to (*<Euro(5).operator+( Euro(2) )>*),
    // doesn't work for (*<2 + Euro(5)>*), (*<2>*) is not a calling object of type (*<Euro>*) !
    Euro operator+(const Euro& amount); 
    friend Euro operator+(const Euro& amount1, const Euro& amount2);
private:
    int euro;
    int cents;
};
\end{lstlisting}
$\Rightarrow$ As friend members:
\begin{lstlisting}
class Euro
{
    // constructor for  (*<euro>*)
    Euro(int euro);
    // constructor for (*<euro>*) and (*<cents>*)
    Euro(int euro, int cents);
    // works for every combination (*<int>*) arguments are converted by 
    // the constructor to (*<Euro>*) objects
    friend Euro operator+(const Euro& amount1, const Euro& amount2);
    // insertion and extraction operators
    friend ostream& operator<<(ostream& outs, const Euro& amount);
    friend istream& operator>>(istream& ins, Euro& amount);
private:
    int euro;
    int cents;
};
\end{lstlisting}
%
% Copy constructor / Assignment operator
%
\section{Copy constructor}
\small
$\Rightarrow$ If not defined, C++ automatically adds the default copy
constructor and the default assignment operator.
They might not be correct if dynamic variables are used,
because class members are simply copied.
\begin{lstlisting}
class Int_list
{
    // constructor with size of the list
    Int_list(int size);
    // copy constructor
    Int_list(Int_list& list);
    // assignment operator
    Int_list& operator=(const Int_list& list);
private:
    int *p;
    int size;
}

// call the copy constructor
// (*<second\_list>*) is initialised from (*<first\_list>*)
Int_list second_list(first_list); 

// call the assignment operator
third_list = first_list;
\end{lstlisting}
%
% Inheritance
%
\section{Inheritance}
\small
$\Rightarrow$ Constructors, desctructor, private member functions, copy constructor
and assignment operator are not inherited! Derived classes get the default ones
if they are not explicitely provided but are present in the base class.
\begin{lstlisting}
// a simple book class
class Book
{
public:
    Book(string t, int p);
    void print(ostream& os);
protected:
    int pages;
    string title;
};
\end{lstlisting}
$\Rightarrow$ Redefinition of function members:
\begin{lstlisting}
// a simple textbook class
class Textbook : public Book
{
public:
    Textbook(string t, int p, string s);
    // redefinition of (*<print()>*) from the base class
    void print(ostream& os);
protected:
    string subject;
};
\end{lstlisting}
$\Rightarrow$ \textbf{protecetd} members can be accessed
by derived function members:
\begin{lstlisting}
// has access to (*<protected>*) members of he base class
void Textbook::print(ostream& os)
{
    os << "The title of this textbook is '" << title
         << " and the textbook has " << pages << " pages."  << endl;
    os << "The subject is \"" << subject << "\"" << endl;
}
\end{lstlisting}
$\Rightarrow$ With redefinition, no polymorphism!
\begin{lstlisting}
TextBook a_Math_Textbook("Calculus",1200,"Real variables");
Book *a_book = &a_Math_Textbook;

// call (*<Book::print()>*) not (*<Textbook::print()>*)!
a_book->print(cout);
\end{lstlisting}
%
% Polymorphism
%
\section{Polymorphism}
\small
$\Rightarrow$ \textbf{virtual} allows for late binding, i.e.
polymorphism. Function members are
overridden in the derived class.\\
Note: Destructors should also be
declared \textbf{virtual}. When derived
objects are referenced by base class
pointers, the destructor of the derived class
is called if it is declared virtual.
\begin{lstlisting}
// a simple book class
class Book
{
public:
    Book(string t, int p);
    virtual ~Book();
    void print(ostream& os);
protected:
    int *pages;
    string *title;
};

Book::Book(string t, int p)
{
    pages = new int(p);
    title = new string(t);
}

Book::~Book()
{
    delete pages;
    delete title;
}

// a simple textbook class
class Textbook : public Book
{
public:
    Textbook(string t,int p, string s);
    virtual ~Textbook();
    // overriding of (*<print()>*)  from the base class
    virtual void print(ostream& os);
protected:
    string *subject;
};

Textbook::Textbook(string t, int p, string s) : Book(t, p)
{
    subject = new string(s);
}

Textbook::~Textbook()
{
    delete subject;
}

TextBook a_Math_Textbook("Calculus",1200,"Real variables");
Book *a_book = &a_Math_Textbook;

// call (*<Textbook::print()>*)!
a_book->print(cout);
\end{lstlisting}
%
% Exceptions
%
\section{Exceptions}
\small
$\Rightarrow$ The value thrown by
\textbf{throw} can be of any type.
\begin{lstlisting}
// exception class
class My_exception
{
public:
    My_exception(string s);
    virtual ~My_exception();
    friend ostream& operator<<(ostream& os, const My_exception& e);
protected:
    string msg;
};

try
{
    throw My_exception("error");
}
catch (My_exception& e)
{
    // error stream
    cerr << e;
}
// everything else
catch (...)
{
    exit(1);
}
\end{lstlisting}
$\Rightarrow$ The standard library defines a hierarchy of exceptions.  For example \textbf{runtime\_error} can be 
thrown when runtime errors occur:
\begin{lstlisting}
try
{
    throw runtime_error("unexpected result!");
}
catch (runtime_error& e)
{
    // error stream
    cerr << "runtime error: " << e.what() << "\n";
    return 1;
}
\end{lstlisting}
$\Rightarrow$ Functions throwing exceptions should list the exceptions thrown in
the exception specification list. These exceptions are not 
caught by the function itself!
\begin{lstlisting}
// exceptions of type (*<DivideByZero>*) or (*<OtherException>*) are
// to be caught outside the function. All other exceptions end the program
// if not caught inside the function.
void my_function( ) throw (DivideByZero, OtherException);

// empty exception list, i.e. all exceptions end the program if thrown but
// not caught inside the function.
void my_function( ) throw ( );

// all exceptions of all types treated normally.
void my_function( );
\end{lstlisting}
%
% Templates
%
\section{Templates}
\small
$\Rightarrow$ Function templates:\\ \\
C++ does not need 
the template declaration.
The template function
definition is included directly.
\begin{lstlisting}
// generic swap function
template<class T>
void swap(T& a, T& b)
{
    T temp = a;
    
    a = b;
    b = temp;
}

int a, b;
char c, d;

// swaps two (*<int>*)s
swap(a, b);

// swaps two (*<char>*)s
swap(c, d);
\end{lstlisting}
$\Rightarrow$ Class templates:\\ \\
Methods are defined as 
template functions.
Note the declaration
of the templated friend operator.
\begin{lstlisting}
template<class T>
class A_list
{
    // constructor with size of the list
    A_list(int size);
    // destructor
    ~A_list();
    // copy constructor
    A_list(A_list<T>& b);
    // assignment operator
    A_list<T>& operator=(const A_list<T>& b);
    // friend insertion operator
    template <class TT>
    friend ostream& operator<<(ostream& outs, const A_list<TT>& rhs);
private:
    T *p;
    int size;
}

// constructor definition
template<class T>
A_list<T>::A_list(int size)
{
    p = new T[size];
}

// variable declaration
A_list<double> list;
\end{lstlisting}
%
% Iterators
%
\section{Iterators}
\small
$\Rightarrow$ An iterator is a generalization of a pointer. Different containers have
different iterators.
\begin{lstlisting}
#include <vector>

vector<int> v = {1,2,3,4,5};
// mutable iterator
vector<int>::iterator e;

// bidirectional access
e = v.begin();
++e;
// print (*<v[1]>*)
cout << *e << endl;
--e;
// print (*<v[0]>*)
cout << *e << endl;

// random access
e = v.begin();
// print (*<v[3]>*)
cout << e[3] << endl;

// change an element
e[3] = 9;

// constant iterator (only read)
vector<int>::constant_iterator c;

// print out the vector content (read only)   
for (c = v.begin(); c != v.end(); c++)
    cout << *c << endl;

// not allowed
// (*<c[2] = 2;>*)

// reverse iterator
vector<int>::reverse_iterator r;

// print out the vector content in reverse order
for (r = v.rbegin(); r != v.rend(); r++)
    cout << *r << endl;
\end{lstlisting}
%
% Containers
%
\section{Containers}
\small
$\Rightarrow$ Sequential containers: \textbf{list}
\begin{lstlisting}
#include <list>

list<double> data = {1.32,-2.45,5.65};

// adds elements
data.push_back(9.23);
data.push_front(-3.94);

// bidirectional iterator, no random access    
list<double>::iterator e;

// erase    
e = data.begin();
++e;
data.erase(e);

// print out the content    
for (e = data.begin(); e != data.end(); e++)
    cout << *e << endl;
\end{lstlisting}
$\Rightarrow$ Adapter containers: \textbf{stack}
\begin{lstlisting}
#include <stack>

stack<double> numbers;

// push on the stack
numbers.push(5.65);
numbers.push(-3.95);
numbers.push(6.95);

// size
cout << numbers.size()

// read top data element
double d = numbers.top();

// pop top element
numbers.pop();
\end{lstlisting}
$\Rightarrow$ Associative containers: \textbf{set}
\begin{lstlisting}
#include <set>

set<char> letters;

// inserting elements    
letters.insert('a');
letters.insert('d');
// no duplicates!
letters.insert('d');
letters.insert('g');

// erase    
letters.erase('a');

// const iterator 
set<char>::const_iterator c;   
for (c = letters.begin(); c != letters.end(); c++)
    cout << *c << endl;
\end{lstlisting}
$\Rightarrow$ Associative containers: \textbf{map}
\begin{lstlisting}
#include <string>
#include <map>
#include <utility>

// initialization
map<string,int> dict = { {"one",1}, {"two",2} };
pair<string,int> three("three",3);

// insertion    
dict.insert(three);
dict["four"] = 4;
dict["five"] = 5;

// iterator    
map<string,int>::iterator two;

// find    
two = dict.find("two");

// erase    
dict.erase(two);

// ranged loop
for (auto n : dict)
    cout << "(" <<  n.first << "," <<  n.second << ")" << endl;
\end{lstlisting}
%
% Algorithms
%
\section{Algorithms}
\small
$\Rightarrow$ Provided by the C++ standard library:
\begin{lstlisting}
#include <vector>
#include <algorithm>

vector<int> v = {6,2,7,13,4,3,1};
vector<int>::iterator p;

// find
p = find(v.begin(),v.end(),13);

// merge sort
sort(v.begin(),v.end());

// binary search
bool found;
found = binary_search(v.begin(), v.end(), 3);

// reverse
reverse(v.begin(),v.end());
\end{lstlisting}
%
% Bibliography
%
\small
\begin{thebibliography}{99}
\bibitem{savitch} Walter Savitch. \textsl{Problem Solving with C++}, 10th edition. Pearson Education, 2018
\bibitem{stroustrup} Bjarne Stroustrup. \textsl{Programming: Principles and Practice Using C++}, 2nd edition. Addison Wesley, 2015
\bibitem{lospinoso} Josh Lospinoso. \textsl{C++ Crash Course: A Fast-Paced Introduction}, 1st edition. No Starch Press, 2019
\end{thebibliography}
\end{document}
