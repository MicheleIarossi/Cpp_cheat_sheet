%
%    Another C++ cheat sheet but written in LaTeX to be printed out on A3 paper
%    Copyright (C) 2021 Michele Iarossi - michele@mathsophy.com
%
%    This program is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation version 3 of the License.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program.  If not, see <https://www.gnu.org/licenses/>.
%
%
% Example of document composed in LaTeX
%
%
% Source file ending with .tex
%

% Preamble starts here: includes further global commands and specifications
% In the following, the option 10pt is a global option passed to all
% the packages
\documentclass[10pt]{article}

% Using Courier font
\renewcommand{\ttdefault}{pcr}

% A4 paper size
\usepackage[a4paper]{geometry}

% Change the color of the text
\usepackage{xcolor}
\definecolor{codegray}{gray}{0.78}

% multiple columns in the toc
\usepackage{multicol}

% Add filling dots for sections in the toc
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

% C++ code listings embedded in the document
\usepackage{listings}
\lstset{
    language = [11]C++,
    basicstyle = \ttfamily,
    keywordstyle=\bfseries,
    escapeinside={(*<}{>*)},          % if you want to add LaTeX within your code
    backgroundcolor = \color{codegray},
    xleftmargin = 1.2cm,
    framexleftmargin = 1em
}

% This encoding corresponds to the encoding used by TexShop for saving this file
% The option utf8 is a local option, valid only for the package inputenc
\usepackage[utf8]{inputenc}

% Layout package shows the layout of the page
% You can issue the command \layout for printing the applied layout of the pages
\usepackage{layout}

% Some length parameters are rubber lengths: they stretch or reduce as needed
% 1ex means one time the height of the letter x
% Customize page layout for more space
\setlength{\parskip}{1ex plus0.5ex minus0.2ex}

% No header, only footer
\usepackage{fancyhdr}
\fancypagestyle{plain}{
    \fancyfoot[L]{\small www.mathsophy.com}
    \fancyfoot[C]{\small \thepage}
    \fancyfoot[R]{\small GNU GPL v3.0}}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\fancyhead{}
\fancyfoot[L]{\small www.mathsophy.com}
\fancyfoot[C]{\small \thepage}
\fancyfoot[R]{\small GNU GPL v3.0}

\setcounter{secnumdepth}{0} % sections are level 1

\usepackage[british]{babel}

% This is the body: text mixed with commands

% Commands have the following general syntax:
% \name[optional]{mandatory}
\begin{document}

% Set title and author
\title{\emph{C++ code snippets}}
\author{Michele Iarossi\thanks{\texttt{michele@mathsophy.com}}}
\date{\small \today~-~Version 1.40~-~GNU GPL v3.0}

%\layout

\maketitle

\small

\begin{frame}{}
\setlength\columnsep{1cm}
\begin{multicols}{2}
\tableofcontents
\end{multicols}
\end{frame}

\noindent
In the following code snippets, the standard I/O library and namespace are always used:
\begin{lstlisting}
#include <iostream>
using namespace std;
\end{lstlisting}

\newpage
%
% Type safety
%
\section{Type safety}
\small
\begin{enumerate}
\item[$\Rightarrow$] Universal and uniform initialisation prevents narrowing conversions from happening:
\end{enumerate}
\begin{lstlisting}
// safe conversions
double x {54.21};
int a {2342};

// unsafe conversions (compile error!)
int y {x};
char b {a};
\end{lstlisting}
%
% constexpr
%
\section{constexpr}
\small
There are two options:
\begin{enumerate}
\item[$\Rightarrow$] \textbf{constexpr} must be known at compile time:
\end{enumerate}
\begin{lstlisting}
constexpr int max = 200;
constexpr int c = max + 2;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] \textbf{const} variables don't change at runtime. They cannot be declared as
\textbf{constexpr} because their value is not known at compile time:
\end{enumerate}
\begin{lstlisting}
// the value of (*<n>*) is not known at compile time
const int m = n + 1;
\end{lstlisting}
%
% Type casting
%
\section{Type casting}
\small
\begin{enumerate}
\item[$\Rightarrow$] Use \textbf{static\_cast} for normal casting:
\end{enumerate}
\begin{lstlisting}
// (*<int 15>*) to (*<double 15.0>*)
double num;
num = static_cast<double>(15);
\end{lstlisting}
%
% Functions
%
\section{Functions}
\small
\begin{enumerate}
\item[$\Rightarrow$] With default trailing arguments only in the function declaration:
\end{enumerate}
\begin{lstlisting}
// if (*<year>*) is omitted, then (*<year = 2000>*)
void set_birthday(int day, int month, int year=2000);
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Omitting the name of an argument if not used anymore in the function definition:
\end{enumerate}
\begin{lstlisting}
// argument (*<year>*) is not used anymore in the function definition
// (doesn't break legacy code!)
void set_birthday(int day, int month, int) { ...}
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] With read-only, read-write and copy-by-value parameters:
\end{enumerate}
\begin{lstlisting}
// (*<day>*) input parameter passed by const reference (read-only)
// (*<month>*) output parameter to be changed by the function (read-write)
// (*<year>*) input parameter copied-by-value
void set_birthday(const int& day, int& month, int year);
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Use a function for initialising an object with a complicated initialiser (we might not
know exactly when the object gets initialised):
\end{enumerate}
\begin{lstlisting}
const Object& default_value()
{
  static const Object default(1,2,3);
  return default;
}
\end{lstlisting}

%
% Namespaces
%
\section{Namespaces}
\small
\begin{enumerate}
\item[$\Rightarrow$] \textbf{using} declarations for avoiding fully qualified names:
\end{enumerate}
\begin{lstlisting}
// use (*<string>*) instead of (*<std::string>*)
using std::string;

// use (*<cin>*), (*<cout>*) instead of (*<std::cin>*), (*<std::cout>*)
using std::cin;
using std::cout;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] \textbf{using namespace} directives for including the whole namespace:
\end{enumerate}
\begin{lstlisting}
using namespace std;
\end{lstlisting}
%
% Random numbers
%
\section{Random numbers}
\small
\begin{lstlisting}
#include <cstdlib>
#include <ctime>

// seed the generator
srand( time(0) );

// integer random number between 0 and RAND_MAX
int n = rand();
\end{lstlisting}
%\columnbreak
%
% Arrays
%
\section{Arrays}
\small
\begin{enumerate}
\item[$\Rightarrow$] Range-based \textbf{for} statement:
\end{enumerate}
\begin{lstlisting}
// changes the values and outputs 3579
int arr[] = {2, 4, 6, 8};

for (int& x : arr)
  x++;

for (auto x : arr)
  cout << x;
\end{lstlisting}
%
% Pointers
%
\section{Pointers}
\small
\begin{enumerate}
\item[$\Rightarrow$] Simple object:
\end{enumerate}
\begin{lstlisting}
// simple pointer to (*<double>*)
double *d = new double(5.123);

// delete the storage on the free store
delete d;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Dynamic array:
\end{enumerate}
\begin{lstlisting}
// dynamic array of (*<10 double>*)s
double *dd = new double[10];

// delete the storage on the free store
delete [] dd;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Dynamic matrix:
\end{enumerate}
\begin{lstlisting}
// dynamic matrix of (*<5 x 5 double>*)s memory allocation
double **m = new double*[5];
for (int i=0; i<5; i++)
    m[i] = new double[5];

// memory initialisation    
for (int i=0; i<5; i++)
    for (int j=0; j<5; j++)
        m[i][j] = i*j;

// memory deallocation
for (int i=0; i<5; i++)
    delete[] m[i];
delete[] m;
\end{lstlisting}
%
% C-Strings
%
\section{C-Strings}
\small
\begin{enumerate}
\item[$\Rightarrow$] Legacy strings from C:
\end{enumerate}
\begin{lstlisting}
#include <cstring>
#include <cstdlib>

// (*<C-string>*) for max 10 characters
// long string + null char '\0'
const int SIZE = 10 + 1;
char msg[SIZE] = "Hello!";

// correct looping over (*<C-string>*)s
int i = 0;
while ( msg[i] != '\0' && i < SIZE)
{
   // process msg[i]
}

// safe string copy, at most 10 characters are copied
strncpy(msg, srcStr, 10);

// safe string compare, at most 10 characters are compared
strncmp(msg, srcStr, 10);

// safe string concatenation, at most 10 characters are concatenated
strncat(msg, srcStr, 10);

// from (*<C-string>*) to (*<int>*), (*<long>*), (*<float>*)
int    n = atoi("567");
long   n = atol("1234567");
double n = atof("12.345");
\end{lstlisting}
%
% Input-output streams
%
\section{Input-output streams}
\small
\begin{enumerate}
\item[$\Rightarrow$] Input stream \textbf{cin}, output stream \textbf{cout}, error stream \textbf{cerr}:
\end{enumerate}
\begin{lstlisting}
int number;
char ch;

// read a number followed by a character
// from standard input (keyboard)
// (ignores whitespaces, newlines, etc.)
cin >> number >> ch;

// write on standard output (display)
cout << number << " " <<  ch << endl;

// write error message on standard error (display)
cerr << "Wrong input!\n";
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Integer format manipulators: once a  manipulator is set, it stays until another one is set, i.e. manipulators are \emph{sticky}.
\end{enumerate}
\begin{lstlisting}
#include <iomanip>

// set decimal, octal, or hexadecimal notation,
// and show the base, i.e. (*<0>*) for octal and (*<0x>*) for hexadecimal
cout << showbase;
cout << dec << 1974 << endl;
cout << oct << 1974 << endl;
cout << hex << 1974 << endl;
cout << noshowbase;

// values can be read from input in decimal, octal
// or hexadecimal format previous unsetting
// of all the flags
cin.unsetf(ios::dec);
cin.unsetf(ios::oct);
cin.unsetf(ios::hex);

//  now (*<val>*) can be inserted in any format
cin >> val;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Floating point format manipulators:  once a  manipulator is set, it stays until another one is set, i.e. manipulators are \emph{sticky}.
\end{enumerate}
\begin{lstlisting}
#include <iomanip>

// set default, fixed, or scientific notation
cout << defaultfloat << 1023.984;
cout << fixed << 1023.984;
cout << scientific << 1023.984;

// set precision
cout << setprecision(2) << 1023.984;

// set character text width
cout << setw(10);

// set left or right alignment
cout << left  << 1023.984;
cout << right << 1023.984;

// always show decimal point and zeros
cout << showpoint << 0.532;

// always show plus sign
cout << showpos << 3.64;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Single characters read and write:
\end{enumerate}
\begin{lstlisting}
// read any character from (*<cin>*) (doesn't skip spaces, newlines, etc.)
char nextChar;
cin.get(nextChar);

// write a character to (*<cout>*)
cout.put(nextChar)

// read a whole line of 80 chars
char line[80+1];
cin.getline(line,81);

// put back (*<nextChar>*) to (*<cin>*), (*<nextChar>*) will be the next 
// char read by (*<cin.get()>*)
cin.putback(nextChar);

// put back the last char got from (*<cin.get()>*) to (*<cin>*)
cin.unget();
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] If the input pattern is unexpected, it is possible to set the state of \textbf{cin} to failed:
\end{enumerate}
\begin{lstlisting}
try
{
    // check for unexpected input
    char ch;
    if ( cin >> ch && ch != expected_char )
    {
        // put back last character read
        cin.unget();
        
        // set failed bit
        cin.clear(ios_base::failbit);
    
        // throw an exception or deal with failed stream
        throw runtime_error("Unexpected input");
    }
}
catch (runtime_error e)
{
    cerr << "Error! " << e.what() << "\n";
            
    // check for failure
    if (cin.fail())
    {
        // clear failed bit
        cin.clear();
                
        // read wrong input
        string wrong_input;
        cin >> wrong_input;
                    
        cerr << "Got '" << wrong_input[0] << "'\n";
    }
     // End of file (eof) or corrupted state (bad)
    else return 1;
}
\end{lstlisting}

%
% Files
%
\section{Files}
\small
\begin{enumerate}
\item[$\Rightarrow$] Accessed by means of \textbf{ifstream} (input) or
\textbf{ofstream} (output) objects:
\end{enumerate}
\begin{lstlisting}
#include <fstream>

// open input file 
ifstream in_stream {"infile.dat"};
// open output file
ofstream out_stream {"outfile.dat"};
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Accessed both in input and output mode by means of \textbf{fstream} objects (not recommended):
\end{enumerate}
\begin{lstlisting}
#include <fstream>

// open file in both input and output mode
fstream fs{"inoutfile.dat", ios_base::in | ios_base::out};
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Opened explicitly (not recommended):
\end{enumerate}
\begin{lstlisting}
#include <fstream>

// input file 
ifstream in_stream;
// output file
ofstream out_stream;

// open files
in_stream.open("infile.dat");
out_stream.open("outfile.dat");
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] When checking for failure, the status flag needs to be cleared
in order to continue working with the file:
\end{enumerate}
\begin{lstlisting}
// check for failure on input file
if ( !in_stream )
{
    if ( in_stream.bad() ) error("stream corrupted!");
    
    if ( in_stream.eof() )
    { 
        // no more data available
    }
    
    if ( in_stream.fail() )
    {
        // some format data error, e.g. expected
        // an integer but a string was read
        // recovery is still possible
        
        // set back the state to good 
        // before attempting to read again
        in_stream.clear();
        
        // read again
        string wrong_input;
        in_stream >> wrong_input;
    }
}
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] As for the standard input, if the input pattern is unexpected, it is possible to set the state of the file to failed
and try to recover somewhere else, e.g. by throwing an exception:
\end{enumerate}
\begin{lstlisting}
try
{
    // check for unexpected input
    char ch;
    if ( in_stream >> ch && ch != expected_char )
    {
        // put back last character read
        in_stream.unget();
        
        // set failed bit
        in_stream.clear(ios_base::failbit);
    
        // throw an exception or deal with failed stream
        throw runtime_error("Unexpected input");
    }
}
catch (runtime_error e)
{
    cerr << "Error! " << e.what() << "\n";
            
    // check for failure
    if (in_stream.fail())
    {
        // clear failed bit
        in_stream.clear();
                
        // read wrong input
        string wrong_input;
        in_stream >> wrong_input;
                    
        cerr << "Got '" << wrong_input[0] << "'\n";
    }
    else return 1; // eof or bad
}
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Read and write:
\end{enumerate}
\begin{lstlisting}
// read/write data
in_stream >> data1 >> data2;
out_stream << data1 << data2;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Read a line:
\end{enumerate}
\begin{lstlisting}
string line;
getline(in_stream, line);
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Ignore input (extract and discard):
\end{enumerate}
\begin{lstlisting}
// ignore up to a newline or 9999 characters
in_stream.ignore(9999,'\n');
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Move the file pointer:
\end{enumerate}
\begin{lstlisting}
// skip 5 characters when reading (seek get)
in_stream.seekg(5);
// skip 8 characters when writing (seek put)
out_stream.seekp(8);
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Checking for end of file:
\end{enumerate}
\begin{lstlisting}
// the failing read sets the EOF flag but avoids further processing
while ( in_stream >> next )
{
    // process next
}

// check the EOF flag
if ( in_stream.eof() )
    cout << "EOF reached!" << endl;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] When a file object gets out of scope, the file is closed automatically, but explicit
close is also possible (not recommended):
\end{enumerate}
\begin{lstlisting}
// explicitily close files
in_stream.close();
out_stream.close()
\end{lstlisting}
%
% Strings
%
\section{Strings}
\small
\begin{enumerate}
\item[$\Rightarrow$] Strings as supported by the C++ standard library:
\end{enumerate}
\begin{lstlisting}
#include <string>

// initialization
string s1 = "Hello";
string s2("World");

// concatenation
string s3 = s1 + ", " + s2;

// read a line
string line;
getline(cin,line);

// access to the ith character (no illegal index checking)
s1[i];

// access to the ith character (with illegal index checking)
s1.at(i);

// append
s1.append(s2);

// size and length
s1.size();
s1.length();

// substring from position 5 and length 4 characters
string substring;
substring = s4.substr(5,4);

// find (returns string::npos if not found)
size_t pos;
pos = s3.find("World");
if (pos == string::npos)
    cerr << "Error: String not found!\n";

// find starting from position 5
s3.find("l",5);

// C-string
s3.c_str();

// from (*<string>*) to (*<int>*), (*<long>*), (*<float>*)
int    n = stoi("456");
long   n = stol("1234567");
double n = stod("12.345");

// from numeric type to (*<string>*)
string s = to_string(123.456);
\end{lstlisting}
%
% String streams
%
\section{String streams}
\small
A string is used as a source for an input stream or as a target for an output stream. \\
\begin{enumerate}
\item[$\Rightarrow$] Input string stream \textbf{istringstream}:
\end{enumerate}
\begin{lstlisting}
#include <sstream>

// input string stream
istringstream data_stream{"1.234 -5643.32"};

// read numbers from data stream
double val;
while ( is >> val )
    cout << val << endl;

\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Output string stream \textbf{ostringstream}:
\end{enumerate}
\begin{lstlisting}
#include <sstream>

// output string stream
ostringstream data_stream;

// the same manipulators of input-output streams
// can be used
data_stream << fixed << setprecision(2) << showpos;
data_stream << 6.432 << " " << -313.2134 << "\n";

// the (*<str()>*) method returns the string in the stream
cout << data_stream.str();
\end{lstlisting}

%
% Vectors
%
\section{Vectors}
\small
\begin{enumerate}
\item[$\Rightarrow$] Sequence of elements accessed via an index:
\end{enumerate}
\begin{lstlisting}
#include <vector>

// vector with base type (*<int>*)
vector<int> v = {2, 4, 6, 8};

// vector with 10 elements all initialised to 0
vector<int> v(10);

// access to the (*<i>*)th element
cout << v[i];

// add an element
v.push_back(10);

// range-for-loop
for (auto x : v)
  cout << v << endl;

// size
cout << v.size();

// capacity: number of elements currently allocated
cout << v.capacity();

// reserve more capacity e.g. at least 64 (*<int>*)s
v.reserve(64);
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Throws an \textbf{out\_of\_range} exception if accessed out of bounds:
\end{enumerate}
\begin{lstlisting}
// out of bounds access
vector<int> v = {2, 4, 6, 8};

try
{
    cout << v[7];
} catch (out_of_range)
{
    // access error!
}
\end{lstlisting}
%
% Enumerations
%
\section{Enumerations}
\small
\begin{enumerate}
\item[$\Rightarrow$] \textbf{enum class} defines symbolic constants in the scope of the class:
\end{enumerate}
\begin{lstlisting}
// enum definition
enum class Weekdays
{
    mon=1, tue, wed, thu, fri
};

// usage
Weekdays day = Weekdays::tue;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] \textbf{int}s cannot be assigned to \textbf{enum class} and vice versa:
\end{enumerate}
\begin{lstlisting}
// errors!
Weekdays day = 3;
int d = Weekdays::wed;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] A conversion function should be written which uses unchecked conversions:
\end{enumerate}
\begin{lstlisting}
// valid
Weekdays day = Weekdays(2);
int d = int(Weekdays::fri);
\end{lstlisting}
%
% Classes
%
\section{Classes}
\small
\begin{enumerate}
\item[$\Rightarrow$] If you give no constructor, the compiler will generate a default constructor that does nothing.
If you give at least one constructor, then the C++ compiler will generate no other constructors.
\end{enumerate}
\begin{lstlisting}
class Car
{
public:
    // constructor
    Car(double size);
    // mutators
    void set_engine_size(const double& size);
    // accessors
    double get_engine_size() const;
    // friend function
    friend bool equal(const Car& car1, const Car& car2);
private:	
    double engine_liter;
};

// constructor with member initialisation list
// the member variable is immediately initialised before the
// constructor body runs
Car::Car(double size) : engine_liter{size}
{
}

// parameter passed by reference for efficiency
void Car::set_engine_size(const double& size)
{
    engine_liter = size;
}

// constant member function doesn't change the object
double Car::get_engine_size() const
{
    return engine_liter;
}

// friend function with direct access to private members
bool equal(const Car &car1, const Car &car2)
{
    return car1.engine_liter == car2.engine_liter;
}
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Constructor invocations:
\end{enumerate}
\begin{lstlisting}
// all forms call the (*<Car(2000)>*) constructor
Car bmw {2000};
Car bmw = {2000};
Car bmw = Car{2000};
\end{lstlisting}
%
% Operator overloading
%
\section{Operator overloading}
\small
The behaviour is different if overloaded as class members or 
friend functions.
\begin{enumerate}
\item[$\Rightarrow$] As class members:
\end{enumerate}
\begin{lstlisting}
class Euro
{
    // constructor for  (*<euro>*)
    Euro(int euro);
    // constructor for  (*<euro>*) and (*<cents>*)
    Euro(int euro, int cents);
    // works for (*<Euro(5) + 2>*), equivalent to 
    // (*<Euro(5).operator+( Euro(2) )>*),
    // doesn't work for (*<2 + Euro(5)>*), (*<2>*) is not a calling object
    //  of type (*<Euro>*) !
    Euro operator+(const Euro& amount); 
    friend Euro operator+(const Euro& amount1, const Euro& amount2);
private:
    int euro;
    int cents;
};
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] As friend members:
\end{enumerate}
\begin{lstlisting}
class Euro
{
    // constructor for  (*<euro>*)
    Euro(int euro);
    // constructor for (*<euro>*) and (*<cents>*)
    Euro(int euro, int cents);
    // works for every combination (*<int>*) arguments are converted by 
    // the constructor to (*<Euro>*) objects
    friend Euro operator+(const Euro& amount1, const Euro& amount2);
    // insertion and extraction operators
    friend ostream& operator<<(ostream& outs, const Euro& amount);
    friend istream& operator>>(istream& ins, Euro& amount);
private:
    int euro;
    int cents;
};
\end{lstlisting}
%
% Copy constructor / Assignment operator
%
\section{Copy constructor}
\small
\begin{enumerate}
\item[$\Rightarrow$] If not defined, C++ automatically adds the default copy
constructor and the default assignment operator.
They might not be correct if dynamic variables are used,
because class members are simply copied:
\end{enumerate}
\begin{lstlisting}
class Int_list
{
    // constructor with size of the list
    Int_list(int size);
    // copy constructor
    Int_list(Int_list& list);
    // assignment operator
    Int_list& operator=(const Int_list& list);
private:
    int *p;
    int size;
}

// call the copy constructor
// (*<second\_list>*) is initialised from (*<first\_list>*)
Int_list second_list(first_list); 

// call the assignment operator
third_list = first_list;
\end{lstlisting}
%
% Inheritance
%
\section{Inheritance}
\small
\begin{enumerate}
\item[$\Rightarrow$] Constructors, destructor, private member functions, copy constructor
and assignment operator are not inherited! Derived classes get the default ones
if they are not explicitly provided but are present in the base class.
\end{enumerate}
\begin{lstlisting}
// a simple book class
class Book
{
public:
    Book(string t, int p);
    void print(ostream& os);
protected:
    int pages;
    string title;
};
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Redefinition of function members:
\end{enumerate}
\begin{lstlisting}
// a simple textbook class
class Textbook : public Book
{
public:
    Textbook(string t, int p, string s);
    // redefinition of (*<print()>*) from the base class
    void print(ostream& os);
protected:
    string subject;
};
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] \textbf{protected} members can be accessed
by derived function members:
\end{enumerate}
\begin{lstlisting}
// has access to (*<protected>*) members of he base class
void Textbook::print(ostream& os)
{
    os << "The title of this textbook is '" << title
         << " and the textbook has " << pages << " pages."  << endl;
    os << "The subject is \"" << subject << "\"" << endl;
}
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] With redefinition, no polymorphism!
\end{enumerate}
\begin{lstlisting}
TextBook a_Math_Textbook("Calculus",1200,"Real variables");
Book *a_book = &a_Math_Textbook;

// call (*<Book::print()>*) not (*<Textbook::print()>*)!
a_book->print(cout);
\end{lstlisting}
%
% Polymorphism
%
\section{Polymorphism}
\small
\begin{enumerate}
\item[$\Rightarrow$] \textbf{virtual} allows for late binding, i.e.
polymorphism. Function members are
overridden in the derived class. Note: Destructors should also be
 declared \textbf{virtual}. When derived
objects are referenced by base class
pointers, the destructor of the derived class
is called if it is declared virtual.
\end{enumerate}
\begin{lstlisting}
// a simple book class
class Book
{
public:
    Book(string t, int p);
    virtual ~Book();
    void print(ostream& os);
protected:
    int *pages;
    string *title;
};

Book::Book(string t, int p)
{
    pages = new int(p);
    title = new string(t);
}

Book::~Book()
{
    delete pages;
    delete title;
}

// a simple textbook class
class Textbook : public Book
{
public:
    Textbook(string t, int p, string s);
    virtual ~Textbook();
    // overriding of (*<print()>*)  from the base class
    virtual void print(ostream& os);
protected:
    string *subject;
};

Textbook::Textbook(string t, int p, string s) : Book(t, p)
{
    subject = new string(s);
}

Textbook::~Textbook()
{
    delete subject;
}

TextBook a_Math_Textbook("Calculus",1200,"Real variables");
Book *a_book = &a_Math_Textbook;

// call (*<Textbook::print()>*)!
a_book->print(cout);
\end{lstlisting}
%
% Exceptions
%
\section{Exceptions}
\small
\begin{enumerate}
\item[$\Rightarrow$] The value thrown by
\textbf{throw} can be of any type.
\end{enumerate}
\begin{lstlisting}
// exception class
class My_exception
{
public:
    My_exception(string s);
    virtual ~My_exception();
    friend ostream& operator<<(ostream& os, const My_exception& e);
protected:
    string msg;
};

try
{
    throw My_exception("error");
}
catch (My_exception& e)
{
    // error stream
    cerr << e;
}
// everything else
catch (...)
{
    exit(1);
}
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] The standard library defines a hierarchy of exceptions.  For example \textbf{runtime\_error} can be 
thrown when runtime errors occur:
\end{enumerate}
\begin{lstlisting}
try
{
    throw runtime_error("unexpected result!");
}
catch (runtime_error& e)
{
    // error stream
    cerr << "runtime error: " << e.what() << "\n";
    return 1;
}
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Functions throwing exceptions should list the exceptions thrown in
the exception specification list. These exceptions are not 
caught by the function itself!
\end{enumerate}
\begin{lstlisting}
// exceptions of type (*<DivideByZero>*) or (*<OtherException>*) are
// to be caught outside the function. All other exceptions 
// end the program if not caught inside the function.
void my_function( ) throw (DivideByZero, OtherException);

// empty exception list, i.e. all exceptions end the
// program if thrown but not caught inside the function.
void my_function( ) throw ( );

// all exceptions of all types treated normally.
void my_function( );
\end{lstlisting}
%
% Templates
%
\section{Templates}
\small
Function templates:
\begin{enumerate}
\item[$\Rightarrow$] C++ does not need the template declaration.
The template function definition is included directly.
\end{enumerate}
\begin{lstlisting}
// generic swap function
template<class T>
void swap(T& a, T& b)
{
    T temp = a;
    
    a = b;
    b = temp;
}

int a, b;
char c, d;

// swaps two (*<int>*)s
swap(a, b);

// swaps two (*<char>*)s
swap(c, d);
\end{lstlisting}
Class templates:
\begin{enumerate}
\item[$\Rightarrow$] Methods are defined as template functions.
Note the declaration of the templated friend operator.
\end{enumerate}
\begin{lstlisting}
template<class T>
class A_list
{
    // constructor with size of the list
    A_list(int size);
    // destructor
    ~A_list();
    // copy constructor
    A_list(A_list<T>& b);
    // assignment operator
    A_list<T>& operator=(const A_list<T>& b);
    // friend insertion operator
    template <class TT>
    friend ostream& operator<<(ostream& outs, const A_list<TT>& rhs);
private:
    T *p;
    int size;
}

// constructor definition
template<class T>
A_list<T>::A_list(int size)
{
    p = new T[size];
}

// variable declaration
A_list<double> list;
\end{lstlisting}
%
% Iterators
%
\section{Iterators}
\small
\begin{enumerate}
\item[$\Rightarrow$] An iterator is a generalisation of a pointer. Different containers have
different iterators.
\end{enumerate}
\begin{lstlisting}
#include <vector>

vector<int> v = {1,2,3,4,5};
// mutable iterator
vector<int>::iterator e;

// bidirectional access
e = v.begin();
++e;
// print (*<v[1]>*)
cout << *e << endl;
--e;
// print (*<v[0]>*)
cout << *e << endl;

// random access
e = v.begin();
// print (*<v[3]>*)
cout << e[3] << endl;

// change an element
e[3] = 9;

// constant iterator (only read)
vector<int>::constant_iterator c;

// print out the vector content (read only)   
for (c = v.begin(); c != v.end(); c++)
    cout << *c << endl;

// not allowed
// (*<c[2] = 2;>*)

// reverse iterator
vector<int>::reverse_iterator r;

// print out the vector content in reverse order
for (r = v.rbegin(); r != v.rend(); r++)
    cout << *r << endl;
\end{lstlisting}
%
% Containers
%
\section{Containers}
\small
\begin{enumerate}
\item[$\Rightarrow$] Sequential containers: \textbf{list}
\end{enumerate}
\begin{lstlisting}
#include <list>

list<double> data = {1.32,-2.45,5.65};

// adds elements
data.push_back(9.23);
data.push_front(-3.94);

// bidirectional iterator, no random access    
list<double>::iterator e;

// erase    
e = data.begin();
++e;
data.erase(e);

// print out the content    
for (e = data.begin(); e != data.end(); e++)
    cout << *e << endl;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Adapter containers: \textbf{stack}
\end{enumerate}
\begin{lstlisting}
#include <stack>

stack<double> numbers;

// push on the stack
numbers.push(5.65);
numbers.push(-3.95);
numbers.push(6.95);

// size
cout << numbers.size()

// read top data element
double d = numbers.top();

// pop top element
numbers.pop();
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Associative containers: \textbf{set}
\end{enumerate}
\begin{lstlisting}
#include <set>

set<char> letters;

// inserting elements    
letters.insert('a');
letters.insert('d');
// no duplicates!
letters.insert('d');
letters.insert('g');

// erase    
letters.erase('a');

// const iterator 
set<char>::const_iterator c;   
for (c = letters.begin(); c != letters.end(); c++)
    cout << *c << endl;
\end{lstlisting}
\begin{enumerate}
\item[$\Rightarrow$] Associative containers: \textbf{map}
\end{enumerate}
\begin{lstlisting}
#include <string>
#include <map>
#include <utility>

// initialisation
map<string,int> dict = { {"one",1}, {"two",2} };
pair<string,int> three("three",3);

// insertion    
dict.insert(three);
dict["four"] = 4;
dict["five"] = 5;

// iterator    
map<string,int>::iterator two;

// find    
two = dict.find("two");

// erase    
dict.erase(two);

// ranged loop
for (auto n : dict)
    cout << "(" <<  n.first << "," <<  n.second << ")" << endl;
\end{lstlisting}
%
% Algorithms
%
\section{Algorithms}
\small
\begin{enumerate}
\item[$\Rightarrow$] Provided by the C++ standard library:
\end{enumerate}
\begin{lstlisting}
#include <vector>
#include <algorithm>

vector<int> v = {6,2,7,13,4,3,1};
vector<int>::iterator p;

// find
p = find(v.begin(),v.end(),13);

// merge sort
sort(v.begin(),v.end());

// binary search
bool found;
found = binary_search(v.begin(), v.end(), 3);

// reverse
reverse(v.begin(),v.end());
\end{lstlisting}
%
% Bibliography
%
\small
\begin{thebibliography}{99}
\bibitem{savitch} Walter Savitch. \textsl{Problem Solving with C++}, 10th edition. Pearson Education, 2018
\bibitem{stroustrup} Bjarne Stroustrup. \textsl{Programming: Principles and Practice Using C++}, 2nd edition. Addison Wesley, 2015
\bibitem{lospinoso} Josh Lospinoso. \textsl{C++ Crash Course: A Fast-Paced Introduction}, 1st edition. No Starch Press, 2019
\end{thebibliography}
\end{document}
